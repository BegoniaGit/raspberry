# 前言
若回收算法是方法论,则回收器就是具体的实施者了.

java虚拟机垃圾回收器目前共7个,分别是serial,parnew,
传送门:[回收算法回顾](https://segmentfault.com/a/1190000018519442)
Serial,ParNew,Parallel Scavenge,Serial Old,Parallel Old,CMS和G1收集器.

## 1. 五种基本垃圾回收器概览
![](https://raw.githubusercontent.com/CrabappleProject/raspberry/master/extra/img/五种垃圾收集器.jpg)
传送门[五种收集器介绍清晰的文章](https://blog.csdn.net/u011080472/article/details/51324422)

### 1.1 五种算法的总结
1.由于新生代垃圾远远多于老年代,所以新生代采用**复制算法**比较划算,因为需要复制的实例数据相对较少.
2.由于老年代生命迭代没有新生代频繁,所以垃圾少,因此一般采用标记清除或标记整理,但是标记清除往往会产生大量碎片,因此优选**标记整理**.


## 2. CMS收集器
CMS（Concurrent Mark Sweep）收集器是一种以获取**最短回收停顿时间**为目标的收集器。它而非常符合在注重用户体验的应用上使用。
从名字中的Mark Sweep这两个词可以看出，CMS收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：
- **初始标记**： 暂停所有的其他线程，并记录下直接与root相连的对象，速度很快 ；
- **并发标记**： 同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
- **重新标记**： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短.
- **并发清除**： 开启用户线程，同时GC线程开始对未标记的区域做清扫。
  如图([图片引用自这里](https://blog.csdn.net/u011080472/article/details/51324422)):
  ![CMS垃圾回收图](https://raw.githubusercontent.com/CrabappleProject/raspberry/master/extra/img/CMS垃圾回收图.jpg)
从它的名字就可以看出它是一款优秀的垃圾收集器,总的来看,CMS收集器细化了垃圾收集过程,其中迫不得已独占线程,才使用线程独占,其余都尽量使用了并发,从而降低了系统停顿的时间,也就提高了用户体验感.总结优缺点如下:
主要优点：
1.并发收集(总体而言,并发标记和并发清除占用时间较长,初始标记和重新标记占用时间短很多)
2.低停顿。
明显的缺点：
1.对CPU资源敏感；
2.无法处理浮动垃圾:因为第二步不能实时.
3.它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。

## 3. G1收集器(最新成果)
上一代的垃圾收集器(串行serial, 并行parallel, 以及CMS)都把堆内存划分为固定大小的三个部分: 年轻代(young generation), 年老代(old generation), 以及持久代(permanent generation).
![G1](https://upload-images.jianshu.io/upload_images/8160928-75cf67b5b2138aba)
G1 (Garbage-First)是一款**面向服务器的垃圾收集器**,主要针对配备多颗处理器及大容量内存的机器. 以**极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征**.
被视为JDK1.7中HotSpot虚拟机的一个重要进化特征。它具备一下特点：

- **并行与并发**：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。
- **分代收集**：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。
- **空间整合**：与CMS的“标记--清理”算法不同，G1从**整体来看是基于“标记整理”算法实现**的收集器；从**局部上来看是基于“复制”算法**实现的。
- **可预测的停顿**：这是G1相对于CMS的另一个大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者**明确指定在一个长度为M毫秒的时间片段内**。
G1收集器在后台维护了一个**优先列表**，每次根据允许的收集时间，优先选择**回收价值最大**的Region(这也就是它的名字Garbage-First的由来)。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了GF收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。

G1收集器的运作大致分为以下几个步骤：
- **初始标记**: 标记一下GC Roots能直接关联到的对象.
- **并发标记**: 从GC Root开始对堆中对象进行可达性分析，找出存活的对象，这阶段时耗时较长，但可与用户程序并发执行。
- **最终标记**:修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录.
- **筛选回收**: 回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。

上面几个步骤的运作过程和CMS有很多相似之处。初始标记阶段仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS的值，让下一个阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这一阶段需要停顿线程，但是耗时很短，并发标记阶段是从GC Root开始对堆中对象进行可达性分析，找出存活的对象，这阶段时耗时较长，但可与用户程序并发执行。最终标记阶段则是修正在并发标记阶段因为用户程序的并发执行而导致标记产生变动的那一部分记录，这部分记录被保存在Remembered Set Logs中，最终标记阶段再把Logs中的记录合并到Remembered Set中，这个阶段是并行执行的，仍然需要暂停用户线程。最后在筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。如图(图片来源同上):
![G1回收图](https://raw.githubusercontent.com/CrabappleProject/raspberry/master/extra/img/G1回收图.jpg)

## 4. G1分区模型
在G1之前的垃圾收集器，将堆区主要划分了Eden区，Old区，Survivor区。其中对于Eden，Survivor对回收过程来说叫做“年轻代垃圾收集”。并且年轻代和老年代都分别是连续的内存空间。 
G1将堆分成了若干Region,以下和”分区”代表同一概念。Region的大小可以通过G1HeapRegionSize参数进行设置，其必须是2的幂，范围允许为1Mb到32Mb。 JVM的会基于堆内存的初始值和最大值的平均数计算分区的尺寸，平均的堆尺寸会分出约2000个Region。分区大小一旦设置，则启动之后不会再变化。如下图简单画了下G1分区模型。
![G1分区模型](https://raw.githubusercontent.com/CrabappleProject/raspberry/master/extra/img/G1分区模型.png)
1.Eden regions(年轻代-Eden区)
2.Survivor regions(年轻代-Survivor区) 
3.Old regions（老年代）
4.Humongous regions（巨型对象区域）
5.Free resgions（未分配区域，也会叫做可用分区）-上图中空白的区域

### 分区有几个重要的概念：
- G1还是采用分代回收，但是不同的分代之间内存不一定是连续的，不同分代的Region的占用数也不一定是固定的（不建议通过相关选项显式设置年轻代大小。会覆盖暂停时间目标。）。年轻代的Eden,Survivor数量会随着每一次GC发生相应的改变。      
- 分区是不固定属于哪个分代的，所以比如一次ygc过后，原来的Eden的分区就会变成空闲的可用分区，随后也可能被用作分配巨型对象，成为H区等。     
- G1中的巨型对象是指，占用了Region容量的50%以上的一个对象。Humongous区，就专门用来存储巨型对象。如果一个H区装不下一个巨型对象，则会通过连续的若干H分区来存储。因为巨型对象的转移会影响GC效率，所以并发标记阶段发现巨型对象不再存活时，会将其直接回收。ygc也会在某些情况下对巨型对象进行回收. 
- 通过上图可以看出，分区可以有效利用内存空间，因为收集整体是使用“标记-整理”，Region之间基于“复制”算法，GC后会将存活对象复制到可用分区（未分配的分区），所以不会产生空间碎片。     
- G1类似CMS，也会在比如一次fullgc中基于堆尺寸的计算重新调整（增加）堆的空间。但是相较于执行fullgc，G1 GC会在无法分配对象或者巨型对象无法获得连续分区来分配空间时，优先尝试扩展堆空间来获得更多的可用分区。原则上就是G1会计算执行GC的时间，并且极力减少花在GC上的时间（包括ygc,mixgc）,如果可能，会通过不断扩展堆空间来满足对象分配、转移的需要。                 
- 因为G1提供了“可预测的暂停时间”，也是基于G1的启发式算法，所以G1会估算年轻代需要多少分区，以及还有多少分区要被回收。ygc触发的契机就是在Eden分区数量达到上限时。一次ygc会回收所有的Eden和survivor区。其中存活的对象会被转移到另一个新的survivor区或者old区，如果转移的目标分区满了，会再将可用区标记成S或者O区.
## 结语
此篇文章其图片和知识信心我大量引用了如下文章,需要详细参考的读者,自行浏览,<JVM性能调优实践——G1 垃圾收集器介绍篇>算法部分深度太大,笔者理解不到位,就不整理过来了.
[【深入理解JVM】：HotSpot垃圾收集器](https://blog.csdn.net/u011080472/article/details/51324422)
[JVM性能调优实践——G1 垃圾收集器介绍篇](https://blog.csdn.net/lijingyao8206/article/details/80513383)

