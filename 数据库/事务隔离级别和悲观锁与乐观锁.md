## 前言
事务是访问数据库的一个操作序列，数据库应用系统通过事务集来完成对数据库的存取.
### 1. 什么是事务?
事务必须服从ISO/IEC所制定的ACID原则。ACID是原子性（atomicity）、一致性（consistency）、隔离性（isolation）、持久性（durability）的缩写，这四种状态的意思是：
1. 原子性（Atomicity）
　　原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。
2. 一致性（Consistency）
　　一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态.
3. 隔离性（Isolation）
　　在事务正确提交之前，不允许把事务对该数据的改变提供给任何其他事务，即在事务正确提交之前，它可能的结果不应该显示给其他事务.
4. 持久性（Durability）
　　持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。
### 2.  事务的作用
当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性.
### 3. 遇到的并发问题
1. 第一类丢失更新:A事务撤销时，把已经提交的B事务的更新数据覆盖了.
2. 第二类丢失更新:A事务覆盖B事务已经提交的数据，造成B事务所做操作丢失.
3. 脏读:A事务读取了事务B中未提交的数据.
4. 不可重复读:A事务多次读取的值不同,因为该值被B事务修改并提交了.
5. 幻读:不是事务过程中发生的现象,是用户执行A事务后发现与自己预想的不一致,其实是B事务对其数据执行了修改或插入.
### 4. 如何解决上面的问题呢?
为了解决上面的问题,开发者为MySQL数据库设计了以下四种事务隔离级别:
1. Read Uncommitted(未提交读)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据.

2. Read Committed(提交读)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读).

3. Repeated Read(可重复读)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读，但是innoDB解决了幻读.

4. Serializable(串行读)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞.


|  隔离级别   | 脏读    |   不可重复度    |   不幻读   |
| :--: | :--: | :--: | :--: |
|Read Uncommitted(未提交读)|  可能    |   可能   |   可能   |
|Read Committed(提交读)|  不可能    |   可能   |   可能   |
|Repeated Read(可重复读)|  不可能   | 不可能   |  可能   |
|Serializable(串行读)|  不可能  |   不可能  | 不可能  |
### 5. 小尝试
1. 查看全局或会话的事务隔离级别
````
SELECT @@global.tx_isolation, @@tx_isolation;
````
![事务隔离级别1](https://raw.githubusercontent.com/CrabappleProject/raspberry/master/extra/img/事务隔离级别1.jpg)
2. 修改全局或会话的事务隔离级别
### 6. MySQL默认Repeated Read隔离级别,但这并不能解决幻读问题呀?

