# 死锁

死锁,银行家算法

## 死锁

### 什么是死锁?

死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

### 产生死锁的必要条件

只要任何一个条件都不成立,则不会发生死锁,只有下面的条件全部同时成立时才会发生死锁.

1.互斥条件: 某资源在某一时间段内只能被一个进程占用. 2.请求和保持条件: 进程已经持有一至少一个资源,但是有请求一个新资源,而新资源又被另一个进程占用,此时请求即被阻塞,但对自己活得的资源又不释放. 3.不可抢占条件: 进程已获得的资源在未使用完前**不能被抢占**,只能在进程使用完后自由释放. 4.循环等待条件: 发生死锁时,资源占用必然有个循环等待链.

### 处理死锁的方法

1.预防死锁: 破坏四个必要条件之一或之几. 2.避免死锁: 分配资源时,防止系统进入不安全状态. 3.检测死锁: 程序运行过程中,检测机构能检测出来,并将进程从死锁中解脱出来. 4.解除死锁: 解救进程,常见方法有撤销进程.

### 银行家算法 --- 避免死锁

1.**核心:**当新进程请求一组资源时,系统必须首先确定是否有足够的资源分配给该进程,若有,再进一步计算这些资源分配给进程后,是否会使系统处于不安全状态. 2.**数据结构:**

* Available:系统 每个资源空闲量.
* Max: 各进程对资源的原始需求量.
* Allocation: 已分配给各个线程的资源量.
* Need: 各个线程还需要多少资源量.

  所以: Max=Allocation+Need.

判断是否安全,则能不能找到安全序列.

| 进程\资源情况 | Max | Allocation | Need | Available |
| :--- | :--- | :--- | :--- | :--- |
| p0 | 1  1  1 | 1  1  0 | 0  0  1 | 2  2  2 |
| p1 | 2  1  1 | 1  1  0 | 1  0  1 |  |
| p2 | 1  1  2 | 0  0  0 | 1  1  2 |  |

| 进程\资源情况 | Work | Need | Allocation | Work+Allocation | Finish |
| :--- | :--- | :--- | :--- | :--- | :--- |
| p0 | 2  2  2 | 0  0  1 | 1  1  0 | 3  3  2 | true |
| p1 | 3  3  2 | 1  0  1 | 1  1  0 | 4  4  2 | true |
| p2 | 4  4  2 | 1  1  2 | 0  0  0 | 4  4  2 | true |

所以安全序列为 p0-&gt;p1-&gt;p2,能找到安全序列,所以该系统安全.

